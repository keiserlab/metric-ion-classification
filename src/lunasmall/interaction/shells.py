## Shell generator and handler


from itertools import chain
from collections import defaultdict
import mmh3
import numpy as np

from .filter import AtomGroupNeighborhood

CHEMICAL_FEATURE_IDS = {
    "Aromatic": 1,
    "Acceptor": 2,
    "Donor": 3,
    "Hydrophobe": 4,
    "Hydrophobic": 5,
    "Negative": 6,
    "Positive": 7,
    "Negatively ionizable": 8,
    "Positively ionizable": 9,
    "Halogen donor": 10,
    "Metal": 12,
    "Lumped hydrophobe": 13,
    "Weak donor": 14,
    "Weak acceptor": 15,
    "Electrophile": 16,
    "Nucleophile": 17,
    "Chalcogen donor": 19,
    "Amide": 21,
    "Atom": 22
}

INTERACTION_IDS = {
    "Proximal": 0,
    "Hydrogen bond": 1,
    "Ionic": 2,
    "Salt bridge": 3,
    "Cation-pi": 4,
    "Hydrophobic": 5,
    "Halogen bond": 6,
    "Repulsive": 7,
    "Water-bridged hydrogen bond": 8,
    "Amide-aromatic stacking": 9,
    "Weak hydrogen bond": 10,
    "Covalent bond": 11,
    "Atom overlap": 12,
    "Van der Waals clash": 13,
    "Van der Waals": 14,
    "Chalcogen bond": 15,
    "Chalcogen-pi": 16,
    "Halogen-pi": 17,
    "Orthogonal multipolar": 18,
    "Parallel multipolar": 19,
    "Antiparallel multipolar": 20,
    "Tilted multipolar": 21,
    "Multipolar": 22,
    "Cation-nucleophile": 23,
    "Anion-electrophile": 24,
    "Unfavorable anion-nucleophile": 25,
    "Unfavorable cation-electrophile": 26,
    "Unfavorable nucleophile-nucleophile": 27,
    "Unfavorable electrophile-electrophile": 28,
    "Pi-stacking": 29,
    "Face-to-face pi-stacking": 30,
    "Face-to-edge pi-stacking": 31,
    "Face-to-slope pi-stacking": 32,
    "Edge-to-edge pi-stacking": 33,
    "Edge-to-face pi-stacking": 34,
    "Edge-to-slope pi-stacking": 35,
    "Displaced face-to-face pi-stacking": 36,
    "Displaced face-to-edge pi-stacking": 37,
    "Displaced face-to-slope pi-stacking": 38,
    "Single bond": 39,
    "Double bond": 40,
    "Triple bond": 41,
    "Aromatic bond": 42,
    "Other bond": 43,
    "Metal coordination": 44,
}

class Shell:
    def __init__(self, central_atm_grp,
                 level, radius, neighborhood=None, inter_tuples=None,
                 diff_comp_classes=True, dtype=np.int64, seed=0, manager=None,
                 valid=True, feature_mapper=None):

        self.central_atm_grp = central_atm_grp
        self.level = level
        self.radius = radius
        self.valid = valid
        self.diff_comp_classes = diff_comp_classes

        if not neighborhood:
            neighborhood = ([] if not inter_tuples
                            else [x[1] for x in self._inter_tuples])
        self._neighborhood = set(neighborhood)

        # Always add the central atom in its own neighborhood.
        self._neighborhood.add(central_atm_grp)

        inter_tuples = inter_tuples or []
        self._inter_tuples = set(inter_tuples)

        self._interactions = set([x[0] for x in self._inter_tuples])

        if not feature_mapper:
            default_dict = {**CHEMICAL_FEATURE_IDS, **INTERACTION_IDS}
            feature_mapper = default_dict
        self.feature_mapper = feature_mapper

        self.dtype = dtype
        self.seed = seed

        self._manager = manager

        # Encode the interactions. It represents the substructures comprised by
        # this shell.
        self._encoded_data = self._encode_interactions()
        # Defined in the hash function
        self._identifier = self.hash_shell()

    @property
    def neighborhood(self):
        """iterable of :class:`~luna.mol.groups.AtomGroup`, read-only: \
                All atoms and atom groups within this shell."""
        return self._neighborhood

    @property
    def interactions(self):
        """iterable of :class:`~luna.interaction.type.InteractionType`, \
                read-only: All interactions within this shell."""
        return self._interactions

    @property
    def inter_tuples(self):
        """iterable of tuple, read-only: Each tuple contains an \
                :class:`~luna.interaction.type.InteractionType` object \
                and one of the :class:`~luna.mol.groups.AtomGroup` objects \
                participating to the interaction."""
        return self._inter_tuples

    @property
    def manager(self):
        """`ShellManager`, read-only: The `ShellManager` object that stores \
        and controls this `Shell` object."""
        return self._manager

    @property
    def identifier(self):
        """int, read-only: This shell identifier, which is generated by \
        hashing its encoded data with a hash function. By default, LUNA \
        uses MurmurHash3 as the hash function."""
        return self._identifier

    @property
    def encoded_data(self):
        """iterable of tuple, read-only: The data encoded in this shell."""
        return self._encoded_data

    @property
    def previous_shell(self):
        """`Shell`, read-only: The previous shell, i.e., a shell centered \
        on the same central :class:`~luna.mol.groups.AtomGroup` object from \
        a previous level. For example, if this shell is in level 5, return \
        a shell from level 4 having the same center."""
        shell = self._manager.get_previous_shell(self.central_atm_grp,
                                                 self.level)
        if shell is None:
            error_msg = ("No previous shell centered in '%s' was found."
                         % self.central_atm_grp)
            logger.exception(error_msg)
            raise ShellCenterNotFound(error_msg)
        return shell

    def is_valid(self):
        """If the shell is valid or not.

        Returns
        -------
         : bool
        """
        return self.valid

    def is_similar(self, shell):
        """ If this shell is similar to ``shell``.

        Two shells are similar if they represent the same substructural
        information.

        Parameters
        ----------
        shell : `Shell`

        Returns
        -------
         : bool
        """

        # The shells' identifiers will be equal when the shells encode the same
        # information and were constructed in the same level.
        if self.level == shell.level:
            if self.identifier == shell.identifier:
                return True
            return False

        # If none of the shells have interactions, check if the shells have
        # equal identifiers.
        if not self.interactions and not shell.interactions:
            # If the identifiers are different, but the shells' central group
            # is the same, it means the shells encode the same information
            # even if their levels are different.
            #
            # OBS: this test is only for fast identification without doing a
            # recursive procedure as the one applied in the ELSE statement.
            if self.central_atm_grp == shell.central_atm_grp:
                return True
            # Although two shells contain different identifiers and their
            # centroids are not the same, they can still be equal if they
            # were obtained in different levels.
            else:
                if self.level > shell.level:
                    return self.previous_shell.is_similar(shell)
                return self.is_similar(shell.previous_shell)

        # If both shells have interactions, check if the interactions are
        # equal.
        elif self.interactions and shell.interactions:
            if self.encoded_data == shell.encoded_data:
                return True
        return False

    def hash_shell(self):
        """Hash this shells' substructural information into a 32-bit integer
        using MurmurHash3.

        Returns
        -------
         : int
            A 32-bit integer representing this shell's substructural
            information.
        """

        if self.level == 0:
            # Get the initial data for the first shell according to the IFP
            # type the user has chosen.
            data = self._initial_shell_data()
        else:
            cent_prev_id = self.previous_shell.identifier

            # Initialization of a new feature vector
            data = [(self.level, cent_prev_id)]

            inter_tuples = []
            for (inter, nb_atm_grp) in self._inter_tuples:
                prev_nb_shell = \
                    self._manager.get_previous_shell(nb_atm_grp, self.level)
                if prev_nb_shell is None:
                    error_msg = ("No previous shell centered in %s was found."
                                 % nb_atm_grp)
                    logger.exception(error_msg)
                    raise ShellCenterNotFound(error_msg)

                # 1st elem: interaction type.
                # 2nd elem: previous identifier of the neighbor atom group;
                inter_tuples.append((self.feature_mapper[inter.type],
                                     prev_nb_shell.identifier))

            # Sort the tuples to avoid dependence on the order in which tuples
            # are added.
            sorted_list = sorted(inter_tuples)

            # Join the interaction information to the feature vector.
            data += sorted_list

        np_array = np.array(data, self.dtype)

        # TODO: Let the user define a hash function
        hashed_shell = mmh3.hash(np_array, self.seed, signed=False)

        return hashed_shell

    def _initial_shell_data(self):
        data = []

        # EIFP uses atomic invariants.
        if self.manager.ifp_type == 'eifp':
            # Shells use atomic invariants as data. In case of atom groups,
            # the data consists of a list of invariants.
            data = sorted([atm.invariants
                           for atm in self.central_atm_grp.atoms])

        # FIFP uses pharmacophore properties for atoms and atoms' group.
        elif self.manager.ifp_type == 'fifp':

            atm_grp_data = [self.feature_mapper[cf.format_name()]
                            for cf in self.central_atm_grp.features]

            if len(self.central_atm_grp.atoms) == 1:
                features = set()
                # It will loop only through one atom and, therefore, it can be
                # removed without losing information. However, if someday I
                # decide to remove the If, then the code for capturing all atom
                # derived features will be already working.
                for atm in self.central_atm_grp.atoms:
                    for atm_grp in atm.atm_grps:
                        if atm_grp != self.central_atm_grp:
                            features.update(atm_grp.features)

                atm_grp_data += [self.feature_mapper[cf.format_name()]
                                 for cf in features]

            data = [sorted(atm_grp_data)]

        return data

    def _encode_interactions(self):
        encoded_data = []
        for inter in self.interactions:
            init_src_shell = \
                self._manager.get_previous_shell(inter.src_grp, 1)
            init_trgt_shell = \
                self._manager.get_previous_shell(inter.trgt_grp, 1)
            shell_ids = tuple(sorted([init_src_shell.identifier,
                                      init_trgt_shell.identifier]))
            encoded_data.append((shell_ids, self.feature_mapper[inter.type]))
        return sorted(encoded_data)

    def __repr__(self):
        return ("<Shell: level=%d, radius=%f, center=%s, interactions=%d>"
                % (self.level, self.radius,
                   self.central_atm_grp, len(self.interactions)))


class ShellManager:
    def __init__(self,
                 num_levels=18,
                 radius_step=0.25,
                 fp_length=4096,
                 ifp_type="eifp"):
        
        self.num_levels = num_levels
        self.radius_step = radius_step
        self.fp_length = fp_length
        self.ifp_type = ifp_type

        self.shells = []

        levels = defaultdict(list)
        centers = defaultdict(lambda: defaultdict(lambda: None))

        self.levels = levels
        self.centers = centers

        self.verbose = True

    @property
    def num_shells(self):
        return len(self.shells)

    @property
    def num_unique_shells(self):
        return len(self.unique_shells)

    @property
    def unique_shells(self):
        return self.get_valid_shells()

    def add_shell(self, shell):
        if shell.level > 0 and len(shell.interactions) == 0:
            shell.valid = False
        else:
            found_shell = self.find_similar_shell(shell)

            if found_shell:
                if found_shell.level < shell.level:
                    shell.valid = False

                elif (found_shell.level == shell.level
                        and found_shell.identifier <= shell.identifier):
                    shell.valid = False

                else:
                    found_shell.valid = False

        self.shells.append(shell)
        self.levels[shell.level].append(shell)
        self.centers[shell.central_atm_grp][shell.level] = shell

    def find_similar_shell(self, shell):
        for added_shell in self.shells:
            # For each group of similar shells, it will exist only
            # one valid shell.
            if added_shell.is_valid():
                if shell.is_similar(added_shell):
                    return added_shell
        return None

    def get_valid_shells(self):
        return [s for s in self.shells if s.is_valid()]

    def get_shells_by_identifier(self, identifier, unique_shells=False):
        if unique_shells:
            return [s for s in self.shells
                    if s.identifier == identifier and s.is_valid()]
        else:
            return [s for s in self.shells if s.identifier == identifier]

    def get_shells_by_level(self, level, unique_shells=False):
        shells = []

        if level in self.levels:
            if unique_shells:
                shells = [s for s in self.levels[level] if s.is_valid()]
            else:
                shells = self.levels[level]
        elif self.verbose:
            logger.warning("The informed level '%d' does not exist." % level)

        return shells

    def get_shells_by_center(self, center, unique_shells=False):
        shells = {}

        if center in self.centers:
            if unique_shells:
                shells = {i: s for i, s in self.centers[center].items()
                          if s.is_valid()}
            else:
                shells = self.centers[center]
        elif self.verbose:
            logger.warning("The informed center '%s' does not exist." % center)

        return shells

    def get_shell_by_center_and_level(self,
                                      center,
                                      level,
                                      unique_shells=False):
        shell = self.centers.get(center, {}).get(level)

        if shell is None and self.verbose:
            print("The informed center '%s' does not exist in "
                           "the level '%d'." % (center, level))

        if unique_shells:
            shell = shell if shell.is_valid() else None

        return shell

    def get_previous_shell(self, center, curr_level, unique_shells=False):

        shell = None
        while curr_level != 0 and shell is None:
            level = curr_level - 1
            shell = self.get_shell_by_center_and_level(center,
                                                       level,
                                                       unique_shells)
            curr_level = level

        return shell

    def get_identifiers(self):
        return sorted([s.identifier for s in self.shells])

    def to_fingerprint(self,
                       length,
                       count_fp=True):

        indices, counts = np.unique(np.asarray(self.get_identifiers(), dtype=np.longlong),
                            return_counts=True)
        folded_indices = indices % length
        
        fp = np.zeros(length)
        fp[folded_indices] = counts

        return fp

    def trace_back_feature(self,
                           feature_id, ifp,
                           unique_shells=False):

        for ori_feature in ifp.unfolding_map[feature_id]:
            yield (ori_feature,
                   self.get_shells_by_identifier(ori_feature, unique_shells))

    def _init_controllers(self):
        levels = defaultdict(list)
        centers = defaultdict(lambda: defaultdict(lambda: None))

        for shell in self.shells:
            levels[shell.level].append(shell)
            centers[shell.central_atm_grp][shell.level] = shell

        self.levels = levels
        self.centers = centers

class ShellGenerator:
    def __init__(self, num_levels, radius_step,
                 fp_length=4096, ifp_type='eifp',
                 diff_comp_classes=True, dtype=np.int64, seed=0,
                 bucket_size=10):

        self.num_levels = num_levels
        self.radius_step = radius_step
        self.fp_length = fp_length
        self.ifp_type = ifp_type
        self.diff_comp_classes = diff_comp_classes

        self.seed = seed
        self.dtype = dtype
        self.bucket_size = bucket_size

    
    def create_shells(self, atm_grps_mngr):
        sm = ShellManager(self.num_levels,
                          self.radius_step,
                          self.fp_length,
                          self.ifp_type)

        all_interactions = atm_grps_mngr.get_all_interactions()
        print(all_interactions)
        neighborhood = set(atm_grps_mngr.atm_grps)

        search_scope = neighborhood
        nbs = AtomGroupNeighborhood(search_scope, self.bucket_size)

        skip_atm_grps = set()
        sorted_neighborhood = sorted(neighborhood)

        level = -1
        for level in range(self.num_levels):
            radius = self.radius_step * level

            for atm_grp in sorted_neighborhood:

                if atm_grp in skip_atm_grps:
                    continue

                all_derived_atm_grps = set([ag for a in atm_grp.atoms for ag in a.atm_grps])

                # In level 0, the number of unique derived groups is 0 as the
                # shell initially only contains information of the centroid.
                unique_derived_atm_grps = []

                shell = None

                if radius > 0:
                    prev_shell = sm.get_previous_shell(atm_grp, level)

                    prev_atm_grps = prev_shell.neighborhood
                    prev_interactions = prev_shell.interactions

                    nb_atm_grps = set(nbs.search(atm_grp.centroid, radius))

                    inter_tuples = set()
                    interactions_to_add = set()

                    # For each atom group from the previous shell.
                    for prev_atm_grp in sorted(prev_atm_grps):
                        # Include the partner's derived groups to the set of
                        # all derived groups.
                        all_derived_atm_grps.update(
                            set([ag for a in prev_atm_grp.atoms for ag in a.atm_grps]))

                        for inter in prev_atm_grp.interactions:

                            partner_grp = inter.get_partner(prev_atm_grp)#self._recover_partner_grp(prev_atm_grp, inter, pseudo_grps_mapping)

                            if partner_grp is not None:
                                if inter not in interactions_to_add and partner_grp in nb_atm_grps:
                                    new_tuple = (inter, partner_grp)

                                    # Ignore interactions that already exists
                                    # in the previous shell to avoid
                                    # duplications in the list of interactions.
                                    # For example, without this control, an
                                    # interaction I between atom A1 and A2
                                    # would appear twice in the list: (I, A1)
                                    # and (I, A2). Thus, it keeps only the
                                    # first interaction that appears while
                                    # increasing the shell.
                                    if inter in prev_interactions and new_tuple not in prev_shell.inter_tuples:
                                        continue

                                    inter_tuples.add(new_tuple)
                                    interactions_to_add.add(inter)

                    # Get valid derived groups, which are those ones inside the
                    # current sphere.
                    valid_derived_atm_grps = \
                        set([ag for ag in all_derived_atm_grps
                             if ag in nb_atm_grps])

                    unique_derived_atm_grps = \
                        valid_derived_atm_grps - prev_atm_grps

                    # It adds a new shell only if there are new interactions
                    # and derived atom groups inside the shell.
                    shell_nb = set([x[1] for x in inter_tuples]) | valid_derived_atm_grps
                    shell_nb.add(atm_grp)

                    shell = Shell(atm_grp, level, radius,
                                  neighborhood=shell_nb,
                                  inter_tuples=inter_tuples,
                                  manager=sm,
                                  diff_comp_classes=self.diff_comp_classes,
                                  seed=self.seed, dtype=self.dtype)
                else:
                    shell = Shell(atm_grp, level, radius, manager=sm,
                                  diff_comp_classes=self.diff_comp_classes,
                                  seed=self.seed, dtype=self.dtype)

                if shell:
                    sm.add_shell(shell)
                    last_shell = shell
                else:
                    last_shell = sm.get_last_shell(atm_grp)

                # Evaluate if the limit of possible substructures for the
                # current centroid (atom group) was reached.
                if last_shell:
                    all_nb_interactions = set(chain.from_iterable([g.interactions for g in last_shell.neighborhood]))
                    valid_interactions = set([i for i in all_nb_interactions
                                              if i.src_grp in neighborhood and i.trgt_grp in neighborhood])

                    interactions_converged = valid_interactions == last_shell.interactions

                    grp_expansions_converged = all_derived_atm_grps == last_shell.neighborhood and len(unique_derived_atm_grps) == 0

                    local_convergence = interactions_converged and grp_expansions_converged
                    # The global convergence occurs when all interactions in
                    # the binding site were already included in the sphere.
                    global_convergence = all_interactions == last_shell.interactions

                    if local_convergence or global_convergence:
                        skip_atm_grps.add(atm_grp)

        return sm